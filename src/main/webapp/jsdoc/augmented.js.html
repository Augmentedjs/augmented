<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: augmented.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: augmented.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Augmented.js - The Core UI Component and package
 *
 * @author Bob Warren
 *
 * @requires Backbone.js
 * @module Augmented
 * @version 0.1.0
 */
(function(root, factory) {

    // Set up Augmented appropriately for the environment. Start with AMD.
    if (typeof define === 'function' &amp;&amp; define.amd) {
        define([ 'backbone', 'exports'],
		function(Backbone, exports) {
	    // Export global even in AMD case in case this script is
	    // loaded with
	    // others that may still expect a global Augmented.
	    root.Augmented = factory(root, exports, Backbone);
	});

	// Next for Node.js or CommonJS.
    } else if (typeof exports !== 'undefined') {
	    var _ = require('backbone');
	factory(root, exports, Backbone);

	// Finally, as a browser global.
    } else {
	    root.Augmented = factory(root, {}, root.Backbone);
    }

}(this, function(root, Augmented, Backbone) {
    /*
     * Save the previous value of the `Augmented` variable, so that it can be
     * restored later on, if `noConflict` is used (just like Backbone)
     */
    var previousAugmented = root.Augmented;
    /**
     * The standard version property
     * @constant VERSION
     */
    Augmented.VERSION = '0.1.0 Pre';
    /**
     * A codename for internal use
     * @constant codename
     */
    Augmented.codename = "Adam Jensen";
    /**
     * A release name to help with identification of minor releases
     * @constant releasename
     */
    Augmented.releasename = "Tai Yong";

    /**
     * Runs Augmented.js in 'noConflict' mode, returning the 'Augmented'
     * variable to its previous owner. Returns a reference to 'this' Augmented
     * object.
     * @function Augmented.noConflict
     */
    Augmented.noConflict = function() {
  		root.Augmented = previousAugmented;
        Backbone.noConflict();
  		return this;
    };

    /**
     * Configuration
     * @property Augmented.Configuration
     */
    Augmented.Configuration = {
        LoggerLevel: "debug",
        MessageBundle: "Messages",
        AsynchronousQueueTimeout: 2000,
        ApplicationInitProcessTimeout: 1000
    };

    /*
     * Base functionality
     * Set of base capabilities used throughout the framework
     * . ajax
     * . extend
     * . result
     * . isFunction
     */

     /**
      * Augmented.extend - Can extend base classes via .extend simular to Backbone.js
      * @function Augmented.extend
      */
    Augmented.extend = Backbone.Model.extend;

    /**
     * Augmented.sync - Base sync method that can pass special augmented features
     * @function Augmented.sync
     */
    Augmented.sync = Backbone.sync;

    /**
     * Augmented.isFunction -
     * returns true if called name is a function
     * simular to jQuery .isFunction method
     * @function Augmented.isFunction
     * @returns true if called name is a function
     */
    var isFunction = Augmented.isFunction = function(name) {
        return Object.prototype.toString.call(name) == '[object Function]';
    };

    /**
     * Augmented.result - returns named property in an object
     * simular to underscore .result method
     * @function Augmented.result
     * @returns named property in an object
     */
    var result = Augmented.result = function(object, property) {
        if (object === null) return;
        var value = object[property];
        return Augmented.isFunction(value) ? value.call(object) : value;
    };

    /**
     * Array.includes - returns is a property is included in the array (can pass an start index)
     * ES7 Polyfill
     * @function Array.includes
     * @param searchElement
     * @param fromIndex
     * @returns true if property is included in an array
     */
    if (!Array.prototype.includes) {
        Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {
            'use strict';
            var O = Object(this);
            var len = parseInt(O.length) || 0;
            if (len === 0) {
                return false;
            }
            var n = parseInt(arguments[1]) || 0;
            var k;
            if (n >= 0) {
                k = n;
            } else {
                k = len + n;
                if (k &lt; 0) {
                    k = 0;
                }
            }
            var currentElement;
            while (k &lt; len) {
                currentElement = O[k];
                if (searchElement === currentElement ||
                    (searchElement !== searchElement &amp;&amp; currentElement !== currentElement)) {
                    return true;
                }
                k++;
            }
            return false;
        };
    }

    /**
     * Array.has - returns is a property is in the array (very fast return)
     * @function Array.has
     * @param key
     * @returns true if property is included in an array
     */
    Array.prototype.has = function(key) {
        return (this.indexOf(key) !== -1);
    };

    /**
     * Utility Package -
     * Small Utilities
     * @namespace Augmented.Utility
     */
    Augmented.Utility = {};

    /**
     * Augmented.Utility.TransformerType &lt;br/>
     * Transformer type for use in the transformer
     * @constant Augmented.Utility.TransformerType
     */
    var transformerType = Augmented.Utility.TransformerType = {
        "string": 0,
        "integer": 1,
        "number": 2,
        "boolean": 3,
        "array": 4,
        "object": 5,
        "null": 6
    };

    /**
     * Augmented.Utility.Transformer &lt;br/>
     * Transform an object, type, or array to another type, object, or array
     * @namespace Augmented.Utility.Transformer
     * @returns returns a transformed object or primitive
     */
    var transformer = Augmented.Utility.Transformer = {
        type: transformerType,
        /**
         * @function transform
         * @memberof Augmented.Utility.Transformer
         * @param source
         * @param type
         */
        transform: function(source, type) {
            var out = null;
            switch(type) {
                case transformerType.string:
                    if (typeof source === 'object') {
                        out = JSON.stringify(source);
                    } else {
                        out = String(source);
                    }
                break;
                case transformerType.integer:
                    out = parseInt(source);
                break;
                case transformerType.number:
                    out = Number(source);
                break;
                case transformerType.boolean:
                    out = Boolean(source);
                break;
                case transformerType.array:
                    if (!Array.isArray(source)) {
                        out = [];
                        out[0] = source;
                    } else {
                        out = source;
                    }
                break;
                case transformerType.object:
                    if (typeof source !== 'object') {
                        out = {};
                        out[source] = source;
                    } else {
                        out = source;
                    }
                break;
            }
            return out;
        },
        /**
         * @function isType
         * @memberof Augmented.Utility.Transformer
         * @param source
         * @returns type of source as Augmented.Utility.TransformerType
         */
        isType: function(source) {
            if (source === null) {
                return transformerType.null;
            } else if (typeof source === 'string') {
                return transformerType.string;
            } else if (typeof source === 'number') {
                return transformerType.number;
            } else if (typeof source === 'boolean') {
                return transformerType.boolean;
            } else if (Array.isArray(source)) {
                return transformerType.array;
            } else if (typeof source === 'object') {
                return transformerType.object;
            }
        }
    };

    /**
     * Augmented.Utility.isString -
     * checks is a value is a String
     * @function Augmented.Utility.isString
     * @param variable to check
     * @returns true if value is a string
     */
    var isString = Augmented.Utility.isString = function(val) {
        return typeof val === 'string' ||
            ((!!val &amp;&amp; typeof val === 'object') &amp;&amp;
            Object.prototype.toString.call(val) === '[object String]');
    };

    /**
     * Object Extend ability simular to jQuery.extend()
     * @function Augmented.Utility.extend
     */
    Augmented.Utility.extend = function() {
    	for(var i=1; i&lt;arguments.length; i++)
    	    for(var key in arguments[i])
    		if(arguments[i].hasOwnProperty(key))
    		    arguments[0][key] = arguments[i][key];
    	return arguments[0];
    };

    /**
     * Setup the rest of jQuery-like eventing and handlers for native xhr
     */
    var aXHR = XMLHttpRequest;
    Augmented.Utility.extend(aXHR, {
        done: function() {},
        fail: function() {},
        always: function() {},
        then: function() {}
    });

    var mockXHR = function(){
         this.responseType = "text";
         this.responseText = "";
         this.async = true;
         this.status = 200;
         this.header = {};
         this.timeout = 70;
         this.open = function(method, uri, async, user, password) {
             this.url = uri;
             this.async = async;
             this.user = user;
             this.method = method;
         };
         this.send = function() { this.onload(); };
         this.setRequestHeader = function(header, value) {
             this.header.header = value;
         };
         this.done = function() {};
         this.fail = function() {};
         this.always = function() {};
         this.then = function() {};
         this.options = {};
     };

    /**
     * AJAX capability using simple jQuery-like API&lt;br/>
     * Supports the following object properties and features:
     * &lt;ul>
     * &lt;li>method&lt;/li>
     * &lt;li>url&lt;/li>
     * &lt;li>async&lt;/li>
     * &lt;li>contentType&lt;/li>
     * &lt;li>dataType&lt;/li>
     * &lt;li>beforeSend function&lt;/li>
     * &lt;li>success callback&lt;/li>
     * &lt;li>failure callback&lt;/li>
     * &lt;li>complete callback&lt;/li>
     * &lt;li>user&lt;/li>
     * &lt;li>password&lt;/li>
     * &lt;li>withCredentials&lt;/li>
     * &lt;li>cache&lt;/li>
     * &lt;li>timeout&lt;/li>
     * &lt;li>mock - special flag for mocking response&lt;/li>
     &lt;/ul>
     * @function Augmented.ajax
     * @param {object} ajaxObject object of configuration properties and callbacks.
     * @returns success or failure callback
     * @example Augmented.ajax({
     *         url: uri,
     *         contentType: 'text/plain',
     *         dataType: 'text',
     *         async: true,
     *         success: function (data, status) { ... },
     *         failure: function (data, status) { ... }
     *     });
     */
    var ajax = Augmented.ajax = function(ajaxObject) {
        logger.debug("Ajax object: " + JSON.stringify(ajaxObject));
        var xhr = null;
  		if (ajaxObject &amp;&amp; ajaxObject.url) {
    	    var method = (ajaxObject.method) ? ajaxObject.method : 'GET';
    	    var cache = (ajaxObject.cache) ? (ajaxObject.cache) : true;

    	    xhr = (ajaxObject.mock) ? new mockXHR() : new aXHR();

            if (ajaxObject.timeout) {
                xhr.timeout = ajaxObject.timeout;
            }
    	    var async = (ajaxObject.async !== undefined) ? ajaxObject.async : true;

    	    // CORS
    	    if (ajaxObject.withCredentials) {
        		xhr.withCredentials = ajaxObject.withCredentials;
        		// Sync Not supported for all browsers in CORS mode
                logger.warn("Augmented.ajax: Sync Not supported for all browsers in CORS mode!");
        		async = true;
    	    }

    	    if (async &amp;&amp; ajaxObject.dataType) {
                xhr.responseType = (ajaxObject.dataType) ? ajaxObject.dataType : 'text';
    	    }

    	    xhr.open(method, encodeURI(ajaxObject.url), async,
    		      (ajaxObject.user !== undefined) ? ajaxObject.user : '',
	            (ajaxObject.password !== undefined) ? ajaxObject.password : '');
    	    xhr.setRequestHeader('Content-Type', (ajaxObject.contentType) ? ajaxObject.contentType : 'text/plain');

    	    if (!cache) {
                xhr.setRequestHeader('Cache-Control', 'no-cache');
    	    }

    	    xhr.onload = function() {
    		    if (xhr.status > 199 &amp;&amp; xhr.status &lt; 300) {
                    if (ajaxObject.success) {
                        ajaxObject.success(xhr.responseText, xhr.status);
                    }
    		    } else if (xhr.status > 399 &amp;&amp; xhr.status &lt; 600) {
                    if (ajaxObject.failure) {
                        ajaxObject.failure(xhr.responseText, xhr.status);
                    }
    		    }
                if (ajaxObject.complete) {
                    ajaxObject.complete(xhr.responseText, xhr.status);
                }
                return xhr;
    	    };

            if (ajaxObject.beforeSend) {
                ajaxObject.beforeSend(xhr);
            }

        	xhr.send();
  		}

        this.done = function() {};
        this.fail = function() {};
        this.always = function() {};
        this.then = function() {};

        return this;
    };

    /* Overide Backbone.ajax so models and collections use Augmented Ajax instead */
    Backbone.ajax = ajax;

    /* Packages */

    /** @namespace Augmented.Logger */
    Augmented.Logger = {};

    /** @constant Augmented.Logger.Type */
    var loggerType = Augmented.Logger.Type = {
        console: "console",
        rest: "rest"
    };

    /** Augmented.Logger.Level
     * @namespace Augmented.Logger.Level
     * @enum { string }
     */
    var loggerLevelTypes = Augmented.Logger.Level = {
        /** info */
        info: "info",
        /** debug */
        debug: "debug",
        /** error */
        error: "error",
        /** warn */
        warn: "warn"
    };

    /**
     * Augmented Logger - abstractLogger
     * @constructor abstractLogger
     * @param {Augmented.Logger.Level} level The level to initialize the logger with
     * @abstract
     */
    var abstractLogger = function(l) {
        this.TIME_SEPERATOR = ":";
        this.DATE_SEPERATOR = "-";
        this.OPEN_GROUP = " [ ";
        this.CLOSE_GROUP = " ] ";

        this.label = loggerLevelTypes;

        this.loggerLevel = (l) ? l : loggerLevelTypes.info;

        this.getLogTime = function() {
            var now = new Date();
            return now.getFullYear() + this.DATE_SEPERATOR + (now.getMonth() + 1) + this.DATE_SEPERATOR + now.getDate() + " " +
                now.getHours() + this.TIME_SEPERATOR + now.getMinutes() + this.TIME_SEPERATOR + now.getSeconds() + this.TIME_SEPERATOR + now.getMilliseconds();
        };

        /**
         * log a message
         * @function log
         * @param message The message to log
         * @param level The level of the log message
         * @memberof abstractLogger
         */
        this.log = function(message, level) {
            if (message) {
                if (!level) {
                    level = loggerLevelTypes.info;
                }

                if (this.loggerLevel === loggerLevelTypes.debug &amp;&amp; level === loggerLevelTypes.debug) {
                    this.logMe(this.getLogTime() + this.OPEN_GROUP + loggerLevelTypes.debug + this.CLOSE_GROUP + message, level);
                } else if (level === loggerLevelTypes.error) {
                    this.logMe(this.getLogTime() + this.OPEN_GROUP + loggerLevelTypes.error + this.CLOSE_GROUP + message, level);
                } else if (level === loggerLevelTypes.warn) {
                    this.logMe(this.getLogTime() + this.OPEN_GROUP + loggerLevelTypes.warn + this.CLOSE_GROUP + message, level);
                } else if (this.loggerLevel === loggerLevelTypes.debug || this.loggerLevel === loggerLevelTypes.info) {
                    this.logMe(this.getLogTime() + this.OPEN_GROUP + loggerLevelTypes.info + this.CLOSE_GROUP + message, level);
                }
            }
        };

        this.info = function(message) {
            this.log(message, loggerLevelTypes.info);
        };
        this.error = function(message) {
            this.log(message, loggerLevelTypes.error);
        };
        this.debug = function(message) {
            this.log(message, loggerLevelTypes.debug);
        };
        this.warn = function(message) {
            this.log(message, loggerLevelTypes.warn);
        };
      /*
       * override this in an instance
       * this.logMe = ...
       */
    };

    var consoleLogger = function() {
        abstractLogger.apply(this, arguments);
    };
    consoleLogger.prototype = Object.create(abstractLogger.prototype);
    consoleLogger.prototype.constructor = consoleLogger;

    consoleLogger.prototype.logMe = function(message, level) {
        if (level === loggerLevelTypes.info) {
            console.info(message);
        } else if (level === loggerLevelTypes.error) {
            console.error(message);
        } else if (level === loggerLevelTypes.debug) {
            console.log(message);
        } else if (level === loggerLevelTypes.warn) {
            console.warn(message);
        } else {
            console.log(message);
        }
    };

    var restLogger = function() {
       abstractLogger.apply(this, arguments);
    };

    restLogger.prototype = Object.create(abstractLogger.prototype);
    restLogger.prototype.constructor = restLogger;
    restLogger.prototype.setURI = function(uri) {
        this.uri = uri;
    };
    restLogger.prototype.logMe = function(message) {
        ajax({
            url: this.uri,
            method: "POST",
            contentType: 'text/plain',
            dataType: 'text',
            async: true,
            data: message,
            success: function (data, status) { this.success(); },
            failure: function (data, status) { this.failure(); }
        });
    };

    Augmented.Logger.LoggerFactory = {
        getLogger: function(type, level) {
            if (type === loggerType.console) {
               return new consoleLogger(level);
            } else if (type === loggerType.rest) {
               return new restLogger(level);
            }
        }
    };

   /* A private logger for use in the framework only */
   var logger = Augmented.Logger.LoggerFactory.getLogger(loggerType.console, Augmented.Configuration.LoggerLevel);

    /**
     * Augmented Array Utility
     * @constructor Augmented.Utility.Array
     * @param array to work with
     */
    Augmented.Utility.Array = function(arr) {
        /**
         * Has returns whether a key exists in the Array
         * @function has
         * @param key {string} name of the key
         * @returns true if the key exists in the Array
         * @memberof Augmented.Utility.Array
         */
    	this.has = function(key) {
    	    return (arr.indexOf(key) !== -1);
    	};
    };

    /**
     * ES6-like Map
     * @constructor Augmented.Utility.AugmentedMap
     * @param myData {object} Map data to fill map
     */
    var augmentedMap = Augmented.Utility.AugmentedMap = function(myData) {
    	this.keys = [];
    	this.data = {};

    	// API

      /**
       * Set the value by key in the map
       * @memberof Augmented.Utility.AugmentedMap
       * @param key {string} name of the key
       * @param value {any} value for the key
       */
    	this.set = function(key, value) {
    	    if (key !== null &amp;&amp; value !== null) {
        		if (!this.data[key]) {
        		    this.keys.push(key);
        		}
        		this.data[key] = value;
    	    }
    	};

      /**
       * Get the value by key in the map
       * @function get
       * @memberof Augmented.Utility.AugmentedMap
       * @param key {string} name of the key
       * @returns The value for the key
       */
    	this.get = function(key) {
    	    return this.data[key];
    	};

      /**
       * Index of the key in the map
       * @function indexOf
       * @memberof Augmented.Utility.AugmentedMap
       * @param key {string} name of the key
       * @returns index of the key
       */
    	this.indexOf = function(key) {
    	    return this.keys.indexOf(key);
    	};

      /**
       * Remove the value by key in the map
       * @function remove
       * @memberof Augmented.Utility.AugmentedMap
       * @param key {string} name of the key
       */
    	this.remove = function(key) {
    	    var i = this.indexOf(key);
    	    this.keys.splice(i, 1);
    	    delete this.data[key];
    	};

      /**
       * Has returns whether a key exists in the map
       * @function has
       * @memberof Augmented.Utility.AugmentedMap
       * @param key {string} name of the key
       * @returns true if the key exists in the map
       */
    	this.has = function(key) {
    	    return (this.indexOf(key) !== -1);
    	};

      /**
       * Iterator forEach key to value in the map
       * @function forEach
       * @memberof Augmented.Utility.AugmentedMap
       * @param fn {function} callback for the iterator
       */
    	this.forEach = function(fn) {
    	    if (typeof fn !== 'function') {
    		    return;
    	    }
    	    var len = this.keys.length;
    	    var i = 0;
    	    var k;
    	    for (i = 0; i &lt; len; i++) {
    		    k = this.keys[i];
    		    fn(k, this.data[k], i);
    	    }
    	};

      /**
       * Get the key for the index in the map
       * @function key
       * @memberof Augmented.Utility.AugmentedMap
       * @param i {number} index of the key
       * @returns the key at index
       */
    	this.key = function(i) {
    	    return this.keys[i];
    	};

      /**
       * The entries value object in the map
       * @function entries
       * @memberof Augmented.Utility.AugmentedMap
       * @returns Array of entries value objects
       */
    	this.entries = function() {
    	    var len = this.keys.length;
    	    var entries = new Array(len);
    	    for (var i = 0; i &lt; len; i++) {
        		entries[i] = {
        			key : this.keys[i],
        			value : this.data[i]
        		};
    	    }
    	    return entries;
    	};

      /**
       * The values in the map as an Array
       * @function values
       * @memberof Augmented.Utility.AugmentedMap
       * @returns values as an Array
       */
    	this.values = function() {
    	    var len = this.keys.length;
    	    var values = new Array(len);
    	    for (var i = 0; i &lt; len; i++) {
    		    values[i] = this.data[i];
    	    }
    	    return values;
    	};

      /**
       * Clear the map
       * @function clear
       * @memberof Augmented.Utility.AugmentedMap
       */
    	this.clear = function() {
    	    this.keys = [];
    	    this.data = {};
    	};

      /**
       * The size of the map in keys
       * @function size
       * @memberof Augmented.Utility.AugmentedMap
       * @returns size of map by keys
       */
    	this.size = function() {
    	    return this.keys.length;
    	};

      /**
       * Represent the map in JSON
       * @function toJSON
       * @memberof Augmented.Utility.AugmentedMap
       * @returns JSON of the map
       */
    	this.toJSON = function() {
    	    return this.data;
    	};

      /**
       * Represent the map in a String of JSON
       * @function toString
       * @memberof Augmented.Utility.AugmentedMap
       * @returns Stringified JSON of the map
       */
    	this.toString = function() {
    	    return JSON.stringify(this.data);
    	};

    	// non-es6 API

      /**
       * Checks of the map is empty (not ES6)
       * @function isEmpty
       * @memberof Augmented.Utility.AugmentedMap
       * @returns true if the map is empty
       */
    	this.isEmpty = function() {
    	    return this.keys.length === 0;
    	};

        /**
         * Mashalls a map
         * @function marshall
         * @memberof Augmented.Utility.AugmentedMap
         */
        this.marshall = function(dataToMarshall) {
            /* dataToMarshall must be the following type of data to parse:
             * Map
             * JSON object with properties (key/value)
             */
            var dataToParse;
            if (dataToMarshall &amp;&amp; dataToMarshall instanceof Augmented.Utility.AugmentedMap) {
                dataToParse = dataToMarshall.toJSON();
            } else if(dataToMarshall &amp;&amp; dataToMarshall instanceof Object &amp;&amp; (Object.keys(dataToMarshall).length > 0)) {
                dataToParse = dataToMarshall;
            } else {
                logger.warn("Could not marshall data: " + JSON.stringify(dataToMarshall));
                return false;
            }
            //logger.debug("data to parse: " + JSON.stringify(dataToParse));

            var props = Object.keys(dataToParse);
            for (var i = 0; i &lt; props.length; i++) {
                var p = props[i];
                var v = dataToParse[p];
                logger.debug("setting " + p + ", " + v);
                this.set(p, v);
            }
            return true;
        };

    	if (myData) {
            return this.marshall(myData);
    	}
    };

    /**
     * Base Classes
     */

    /**
     * Augmented Object
	 * Base class for other classes to extend from
	 * triggers events with Backbone.Events
     * @constructor Augmented.Object
     */
	Augmented.Object = function(options) {
    	this.options = Augmented.Utility.extend({}, Augmented.result(this, 'options'), options);
	    this.initialize.apply(this, arguments);
	};

  /**
   * Entend the Object as a new instance
   * @function Augmented.Object.extend
   * @memberof Augmented.Object
   * @returns Child class of Augmented.Object
   */
  	Augmented.Object.extend = Augmented.extend;

  	Augmented.Utility.extend(Augmented.Object.prototype, Backbone.Events, {
  		initialize: function() {}
	});

    // Security

    /**
    * Security Package and API
    * @namespace Augmented.Security
    */
    Augmented.Security = {};
    Augmented.Security.Client = {};

    var principal = Augmented.Security.Principal = {
        fullName: "",
        id: 0,
        login: "",
        email: ""
    };

    /**
    * Augmented.Security.Context
    * Used as a security data storage class
    * @constructor Augmented.Security.Context
    */
    var securityContext = Augmented.Security.Context = function(principal, permissions) {
        this.principal = (principal) ? principal : "guest";
        this.permissions = (permissions) ? permissions : [];
        this.getPrincipal = function() {
          return this.principal;
        };

        this.getPermission = function() {
          return this.permissions;
        };

        this.setPermissions = function(p) {
          this.permissions = p;
        };

        this.addPermission = function(p) {
          this.permissions.push(p);
        };

        this.removePermission = function(p) {
          var i = this.permissions.indexOf(p);
          this.permissions.splice(i, 1);
        };

        this.hasPermission = function(p) {
          return (this.permissions.indexOf(p) != -1);
        };
    };

    Augmented.Security.ClientType = {
        OAUTH2 : 0,
        ACL: 1
    };

    var abstractSecurityClient = Augmented.Object.extend({
        type: null,
        uri: ""
    });

    Augmented.Security.Client.OAUTH2Client = abstractSecurityClient.extend({
        type: Augmented.Security.ClientType.OAUTH2,
        accessToken: "",
        authorizationToken: "",
        authorize: function(applicationName) {
          // TODO: Go authorize the app and get a token
          this.authorizationToken = "";
        },
        // TODO: Refresh the token and store it
        access: function(principal) {
          this.accessToken = "";
        }
    });

  /** Role/Privilege (ACL) Security
   * assuming data to be the following from an ajax call:
   * login, u
  */
  Augmented.Security.Client.ACLClient = abstractSecurityClient.extend({
    type: Augmented.Security.ClientType.ACL,
    authenticate: function(username, password) {
        var c = null;
        ajax({
            url: this.uri,
            method: "GET",
            user: username,
            password: password,
            success: function(data, status) {
                var p = new principal({
                    fullName: data.fullName,
                    id: data.id,
                    login: data.login,
                    email: data.email
                });
                c = new securityContext(p, data.permissions);
            },
            failure: function(data, status) {
                // TODO: Bundle this perhaps
                throw new Error("Failed to authenticate with response of - " + status);
            }
        });
        return c;
    }
  });

  /**
   * AuthenticationFactory Class
   * Returns a client of given type for use with security
   */
  var authenticationFactory = Augmented.Security.AuthenticationFactory = {
    getSecurityClient: function(clientType) {
          if (clientType === Augmented.Security.ClientType.OAUTH2) {
            return new Augmented.Security.Client.OAUTH2Client();
          } else if (clientType === Augmented.Security.ClientType.ACL) {
            return new Augmented.Security.Client.ACLClient();
          }
        return null;
    }
  };

    /**
     * Augmented.Security.Entry
     * Used to secure a resource
     * @class
     */
  var securityEntry = Augmented.Security.Entry = function(p, neg) {
      this.permissions = (p) ? p : [];
      this.isNegative = (neg) ? neg : false;

      this.getPermissions = function() {
          return this.permissions;
      };
      this.setPermissions = function(p) {
          this.permissions = p;
      };
      this.addPermission = function(p) {
          this.permissions.push(p);
      };
      this.removePermission = function(p) {
          var i = this.permissions.indexOf(p);
          this.permissions.splice(i, 1);
      };
      this.hasPermission = function(p) {
          return (this.permissions.indexOf(p) != -1);
      };
      this.setNegative = function(n) {
          this.isNegative = n;
      };
  };

    /** Validation framework - forked from TV4 and extended
     * @see https://github.com/geraintluff/uri-templates
     * but with all the de-substitution stuff removed
     * @constructor
    */
    var Validator = function() {

	var uriTemplateGlobalModifiers = {
		"+": true,
		"#": true,
		".": true,
		"/": true,
		";": true,
		"?": true,
		"&amp;": true
	};
	var uriTemplateSuffices = {
		"*": true
	};

	function notReallyPercentEncode(string) {
	    return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
		return "%" + doubleEncoded.substring(3);
	    });
	}

	function uriTemplateSubstitution(spec) {
	    var modifier = "";
	    if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
		modifier = spec.charAt(0);
		spec = spec.substring(1);
	    }
	    var separator = "";
	    var prefix = "";
	    var shouldEscape = true;
	    var showVariables = false;
	    var trimEmptyString = false;
	    if (modifier === '+') {
		shouldEscape = false;
	    } else if (modifier === ".") {
		prefix = ".";
		separator = ".";
	    } else if (modifier === "/") {
		prefix = "/";
		separator = "/";
	    } else if (modifier === '#') {
		prefix = "#";
		shouldEscape = false;
	    } else if (modifier === ';') {
		prefix = ";";
		separator = ";";
		showVariables = true;
		trimEmptyString = true;
	    } else if (modifier === '?') {
		prefix = "?";
		separator = "&amp;";
		showVariables = true;
	    } else if (modifier === '&amp;') {
		prefix = "&amp;";
		separator = "&amp;";
		showVariables = true;
	    }

	    var varNames = [];
	    var varList = spec.split(",");
	    var varSpecs = [];
	    var varSpecMap = {};
	    for (var i = 0; i &lt; varList.length; i++) {
		var varName = varList[i];
		var truncate = null;
		if (varName.indexOf(":") !== -1) {
		    var parts = varName.split(":");
		    varName = parts[0];
		    truncate = parseInt(parts[1], 10);
		}
		var suffices = {};
		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
		    suffices[varName.charAt(varName.length - 1)] = true;
		    varName = varName.substring(0, varName.length - 1);
		}
		var varSpec = {
			truncate: truncate,
			name: varName,
			suffices: suffices
		};
		varSpecs.push(varSpec);
		varSpecMap[varName] = varSpec;
		varNames.push(varName);
	    }
	    var subFunction = function (valueFunction) {
		var result = "";
		var startIndex = 0;
		for (var i = 0; i &lt; varSpecs.length; i++) {
		    var varSpec = varSpecs[i];
		    var value = valueFunction(varSpec.name);
		    if (value === null || value === undefined || (Array.isArray(value) &amp;&amp; value.length === 0) || (typeof value === 'object' &amp;&amp; Object.keys(value).length === 0)) {
			startIndex++;
			continue;
		    }
		    if (i === startIndex) {
			result += prefix;
		    } else {
			result += (separator || ",");
		    }
		    if (Array.isArray(value)) {
			if (showVariables) {
			    result += varSpec.name + "=";
			}
			for (var j = 0; j &lt; value.length; j++) {
			    if (j > 0) {
				result += varSpec.suffices['*'] ? (separator || ",") : ",";
				if (varSpec.suffices['*'] &amp;&amp; showVariables) {
				    result += varSpec.name + "=";
				}
			    }
			    result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
			}
		    } else if (typeof value === "object") {
			if (showVariables &amp;&amp; !varSpec.suffices['*']) {
			    result += varSpec.name + "=";
			}
			var first = true;
			for (var key in value) {
			    if (!first) {
				result += varSpec.suffices['*'] ? (separator || ",") : ",";
			    }
			    first = false;
			    result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
			    result += varSpec.suffices['*'] ? '=' : ",";
			    result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
			}
		    } else {
			if (showVariables) {
			    result += varSpec.name;
			    if (!trimEmptyString || value !== "") {
				result += "=";
			    }
			}
			if (varSpec.truncate !== null) {
			    value = value.substring(0, varSpec.truncate);
			}
			result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
		    }
		}
		return result;
	    };
	    subFunction.varNames = varNames;
	    return {
		prefix: prefix,
		substitution: subFunction
	    };
	}

	function UriTemplate(template) {
	    if (!(this instanceof UriTemplate)) {
		return new UriTemplate(template);
	    }
	    var parts = template.split("{");
	    var textParts = [parts.shift()];
	    var prefixes = [];
	    var substitutions = [];
	    var varNames = [];
	    while (parts.length > 0) {
		var part = parts.shift();
		var spec = part.split("}")[0];
		var remainder = part.substring(spec.length + 1);
		var funcs = uriTemplateSubstitution(spec);
		substitutions.push(funcs.substitution);
		prefixes.push(funcs.prefix);
		textParts.push(remainder);
		varNames = varNames.concat(funcs.substitution.varNames);
	    }
	    this.fill = function (valueFunction) {
		var result = textParts[0];
		for (var i = 0; i &lt; substitutions.length; i++) {
		    var substitution = substitutions[i];
		    result += substitution(valueFunction);
		    result += textParts[i + 1];
		}
		return result;
	    };
	    this.varNames = varNames;
	    this.template = template;
	}
	UriTemplate.prototype = {
		toString: function () {
		    return this.template;
		},
		fillFromObject: function (obj) {
		    return this.fill(function (varName) {
			return obj[varName];
		    });
		}
	};
	var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {
	    this.missing = [];
	    this.missingMap = {};
	    this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	    this.schemas = parent ? Object.create(parent.schemas) : {};
	    this.collectMultiple = collectMultiple;
	    this.errors = [];
	    this.handleError = collectMultiple ? this.collectError : this.returnError;
	    if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	    }
	    if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	    }
	    this.errorMessages = errorMessages;
	    this.definedKeywords = {};
	    if (parent) {
		for (var key in parent.definedKeywords) {
		    this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
		}
	    }
	};
	ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
	    this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
	    this.definedKeywords[keyword].push(keywordFunction);
	};
	ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors) {
	    var messageTemplate = this.errorMessages[code] || ErrorMessagesDefault[code];
	    if (typeof messageTemplate !== 'string') {
		return new ValidationError(code, "Unknown error code " + code + ": " + JSON.stringify(messageParams), messageParams, dataPath, schemaPath, subErrors);
	    }
	    // Adapted from Crockford's supplant()
	    var message = messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
		var subValue = messageParams[varName];
		return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
	    });
	    return new ValidationError(code, message, messageParams, dataPath, schemaPath, subErrors);
	};
	ValidatorContext.prototype.returnError = function (error) {
	    return error;
	};
	ValidatorContext.prototype.collectError = function (error) {
	    if (error) {
		this.errors.push(error);
	    }
	    return null;
	};
	ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	    for (var i = startIndex; i &lt; this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	    }
	    return this;
	};
	ValidatorContext.prototype.banUnknownProperties = function () {
	    for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "");
		var result = this.handleError(error);
		if (result) {
		    return result;
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.addFormat = function (format, validator) {
	    if (typeof format === 'object') {
		for (var key in format) {
		    this.addFormat(key, format[key]);
		}
		return this;
	    }
	    this.formatValidators[format] = validator;
	};
	ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	    if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
		    return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '');
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	    }
	    return schema;
	};
	ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	    var schema;
	    if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	    }
	    var baseUrl = url;
	    var fragment = "";
	    if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	    }
	    if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
		    return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
		    return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i &lt; parts.length; i++) {
		    var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
		    if (schema[component] === undefined) {
			schema = undefined;
			break;
		    }
		    schema = schema[component];
		}
		if (schema !== undefined) {
		    return this.resolveRefs(schema, urlHistory);
		}
	    }
	    if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	    }
	};
	ValidatorContext.prototype.searchSchemas = function (schema, url) {
	    if (Array.isArray(schema)) {
		for (var i = 0; i &lt; schema.length; i++) {
		    this.searchSchemas(schema[i], url);
		}
	    } else if (schema &amp;&amp; typeof schema === "object") {
		if (typeof schema.id === "string") {
		    if (isTrustedUrl(url, schema.id)) {
			if (this.schemas[schema.id] === undefined) {
			    this.schemas[schema.id] = schema;
			}
		    }
		}
		for (var key in schema) {
		    if (key !== "enum") {
			if (typeof schema[key] === "object") {
			    this.searchSchemas(schema[key], url);
			} else if (key === "$ref") {
			    var uri = getDocumentUri(schema[key]);
			    if (uri &amp;&amp; this.schemas[uri] === undefined &amp;&amp; this.missingMap[uri] === undefined) {
				this.missingMap[uri] = uri;
			    }
			}
		    }
		}
	    }
	};
	ValidatorContext.prototype.addSchema = function (url, schema) {
	    // overload
	    if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' &amp;&amp; typeof url.id === 'string') {
		    schema = url;
		    url = schema.id;
		}
		else {
		    return;
		}
	    }
	    if (url === getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	    }
	    this.schemas[url] = schema;
	    delete this.missingMap[url];
	    normSchema(schema, url);
	    this.searchSchemas(schema, url);
	};

	ValidatorContext.prototype.getSchemaMap = function () {
	    var map = {};
	    for (var key in this.schemas) {
		map[key] = this.schemas[key];
	    }
	    return map;
	};

	ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	    var list = [];
	    for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
		    list.push(key);
		}
	    }
	    return list;
	};

	ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	    var list = [];
	    for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
		    list.push(key);
		}
	    }
	    return list;
	};

	ValidatorContext.prototype.dropSchemas = function () {
	    this.schemas = {};
	    this.reset();
	};
	ValidatorContext.prototype.reset = function () {
	    this.missing = [];
	    this.missingMap = {};
	    this.errors = [];
	};

	ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	    var topLevel;
	    schema = this.resolveRefs(schema);
	    if (!schema) {
		return null;
	    } else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	    }

	    var startErrorCount = this.errors.length;
	    var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	    if (this.checkRecursive &amp;&amp; data &amp;&amp; typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
		    var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
		    if (schemaIndex !== -1) {
			this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
			return null;
		    }
		}
		if (Object.isFrozen(data)) {
		    frozenIndex = this.scannedFrozen.indexOf(data);
		    if (frozenIndex !== -1) {
			var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
			if (frozenSchemaIndex !== -1) {
			    this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
			    return null;
			}
		    }
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
		    if (frozenIndex === -1) {
			frozenIndex = this.scannedFrozen.length;
			this.scannedFrozen.push(data);
			this.scannedFrozenSchemas.push([]);
		    }
		    scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
		    this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
		    this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
		    if (!data[this.validatedSchemasKey]) {
			try {
			    Object.defineProperty(data, this.validatedSchemasKey, {
				value: [],
				configurable: true
			    });
			    Object.defineProperty(data, this.validationErrorsKey, {
				value: [],
				configurable: true
			    });
			} catch (e) {
			    // IE 7/8 workaround
			    data[this.validatedSchemasKey] = [];
			    data[this.validationErrorsKey] = [];
			}
		    }
		    scannedSchemasIndex = data[this.validatedSchemasKey].length;
		    data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
		    data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	    }

	    var errorCount = this.errors.length;
	    var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;

	    if (topLevel) {
    		while (this.scanned.length) {
    		    var item = this.scanned.pop();
    		    delete item[this.validatedSchemasKey];
    		}
    		this.scannedFrozen = [];
    		this.scannedFrozenSchemas = [];
	    }

	    if (error || errorCount !== this.errors.length) {
    		while ((dataPathParts &amp;&amp; dataPathParts.length) || (schemaPathParts &amp;&amp; schemaPathParts.length)) {
    		    var dataPart = (dataPathParts &amp;&amp; dataPathParts.length) ? "" + dataPathParts.pop() : null;
    		    var schemaPart = (schemaPathParts &amp;&amp; schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
    		    if (error) {
    			    error = error.prefixWith(dataPart, schemaPart);
    		    }
    		    this.prefixErrors(errorCount, dataPart, schemaPart);
    		}
	    }

	    if (scannedFrozenSchemaIndex !== null) {
		    this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	    } else if (scannedSchemasIndex !== null) {
		    data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	    }

	    return this.handleError(error);
	};
	ValidatorContext.prototype.validateFormat = function (data, schema) {
	    if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	    }
	    var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	    if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}).prefixWith(null, "format");
	    } else if (errorMessage &amp;&amp; typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || null, errorMessage.schemaPath || "/format");
	    }
	    return null;
	};
	ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
	    for (var key in this.definedKeywords) {
		if (typeof schema[key] === 'undefined') {
		    continue;
		}
		var validationFunctions = this.definedKeywords[key];
		for (var i = 0; i &lt; validationFunctions.length; i++) {
		    var func = validationFunctions[i];
		    var result = func(data, schema[key], schema, dataPointerPath);
		    if (typeof result === 'string' || typeof result === 'number') {
			return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}).prefixWith(null, "format");
		    } else if (result &amp;&amp; typeof result === 'object') {
			var code = result.code;
			if (typeof code === 'string') {
			    if (!ErrorCodes[code]) {
				throw new Error('Undefined error code (use defineError): ' + code);
			    }
			    code = ErrorCodes[code];
			} else if (typeof code !== 'number') {
			    code = ErrorCodes.KEYWORD_CUSTOM;
			}
			var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
			var schemaPath = result.schemaPath ||( "/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
			return this.createError(code, messageParams, result.dataPath || null, schemaPath);
		    }
		}
	    }
	    return null;
	};

	function recursiveCompare(A, B) {
	    if (A === B) {
		return true;
	    }
	    if (typeof A === "object" &amp;&amp; typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
		    return false;
		} else if (Array.isArray(A)) {
		    if (A.length !== B.length) {
			return false;
		    }
		    for (var i = 0; i &lt; A.length; i++) {
			if (!recursiveCompare(A[i], B[i])) {
			    return false;
			}
		    }
		} else {
		    var key;
		    for (key in A) {
			if (B[key] === undefined &amp;&amp; A[key] !== undefined) {
			    return false;
			}
		    }
		    for (key in B) {
			if (A[key] === undefined &amp;&amp; B[key] !== undefined) {
			    return false;
			}
		    }
		    for (key in A) {
			if (!recursiveCompare(A[key], B[key])) {
			    return false;
			}
		    }
		}
		return true;
	    }
	    return false;
	}

	ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	    var error;
	    if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	    }
	    if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	    }
	    return null;
	};

	ValidatorContext.prototype.validateType = function validateType(data, schema) {
	    if (schema.type === undefined) {
		return null;
	    }
	    var dataType = typeof data;
	    if (data === null) {
		dataType = "null";
	    } else if (Array.isArray(data)) {
		dataType = "array";
	    }
	    var allowedTypes = schema.type;
	    if (typeof allowedTypes !== "object") {
		allowedTypes = [allowedTypes];
	    }

	    for (var i = 0; i &lt; allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" &amp;&amp; dataType === "number" &amp;&amp; (data % 1 === 0))) {
		    return null;
		}
	    }
	    return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")});
	};

	ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	    if (schema["enum"] === undefined) {
		return null;
	    }
	    for (var i = 0; i &lt; schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
		    return null;
		}
	    }
	    return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data});
	};

	ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	    return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;
	};

	var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
	var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
	ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	    var multipleOf = schema.multipleOf || schema.divisibleBy;
	    if (multipleOf === undefined) {
		return null;
	    }
	    if (typeof data === "number") {
		var remainder = (data/multipleOf)%1;
		if (remainder >= CLOSE_ENOUGH_LOW &amp;&amp; remainder &lt; CLOSE_ENOUGH_HIGH) {
		    return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf});
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	    if (typeof data !== "number") {
		return null;
	    }
	    if (schema.minimum !== undefined) {
		if (data &lt; schema.minimum) {
		    return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}).prefixWith(null, "minimum");
		}
		if (schema.exclusiveMinimum &amp;&amp; data === schema.minimum) {
		    return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}).prefixWith(null, "exclusiveMinimum");
		}
	    }
	    if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
		    return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}).prefixWith(null, "maximum");
		}
		if (schema.exclusiveMaximum &amp;&amp; data === schema.maximum) {
		    return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}).prefixWith(null, "exclusiveMaximum");
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateNaN = function validateNaN(data) {
	    if (typeof data !== "number") {
		return null;
	    }
	    if (isNaN(data) === true || data === Infinity || data === -Infinity) {
		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}).prefixWith(null, "type");
	    }
	    return null;
	};

	ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	    return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;
	};

	ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	    if (typeof data !== "string") {
		return null;
	    }
	    if (schema.minLength !== undefined) {
		if (data.length &lt; schema.minLength) {
		    return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}).prefixWith(null, "minLength");
		}
	    }
	    if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
		    return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}).prefixWith(null, "maxLength");
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	    if (typeof data !== "string" || schema.pattern === undefined) {
		return null;
	    }
	    var regexp = new RegExp(schema.pattern);
	    if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}).prefixWith(null, "pattern");
	    }
	    return null;
	};
	ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	    if (!Array.isArray(data)) {
		return null;
	    }
	    return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;
	};

	ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	    var error;
	    if (schema.minItems !== undefined) {
		if (data.length &lt; schema.minItems) {
		    error = (this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems})).prefixWith(null, "minItems");
		    if (this.handleError(error)) {
			return error;
		    }
		}
	    }
	    if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
		    error = (this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems})).prefixWith(null, "maxItems");
		    if (this.handleError(error)) {
			return error;
		    }
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	    if (schema.uniqueItems) {
		for (var i = 0; i &lt; data.length; i++) {
		    for (var j = i + 1; j &lt; data.length; j++) {
			if (recursiveCompare(data[i], data[j])) {
			    var error = (this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j})).prefixWith(null, "uniqueItems");
			    if (this.handleError(error)) {
				return error;
			    }
			}
		    }
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	    if (schema.items === undefined) {
		return null;
	    }
	    var error, i;
	    if (Array.isArray(schema.items)) {
		for (i = 0; i &lt; data.length; i++) {
		    if (i &lt; schema.items.length) {
			if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
			    return error;
			}
		    } else if (schema.additionalItems !== undefined) {
			if (typeof schema.additionalItems === "boolean") {
			    if (!schema.additionalItems) {
				error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {})).prefixWith("" + i, "additionalItems");
				if (this.handleError(error)) {
				    return error;
				}
			    }
			} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
			    return error;
			}
		    }
		}
	    } else {
		for (i = 0; i &lt; data.length; i++) {
		    if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
			return error;
		    }
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	    if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	    }
	    return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;
	};

	ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	    var keys = Object.keys(data);
	    var error;
	    if (schema.minProperties !== undefined) {
		if (keys.length &lt; schema.minProperties) {
		    error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}).prefixWith(null, "minProperties");
		    if (this.handleError(error)) {
			return error;
		    }
		}
	    }
	    if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
		    error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}).prefixWith(null, "maxProperties");
		    if (this.handleError(error)) {
			return error;
		    }
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	    if (schema.required !== undefined) {
		for (var i = 0; i &lt; schema.required.length; i++) {
		    var key = schema.required[i];
		    if (data[key] === undefined) {
			var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}).prefixWith(null, "" + i).prefixWith(null, "required");
			if (this.handleError(error)) {
			    return error;
			}
		    }
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	    var error;
	    for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined &amp;&amp; schema.properties[key] !== undefined) {
		    foundMatch = true;
		    if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
			return error;
		    }
		}
		if (schema.patternProperties !== undefined) {
		    for (var patternKey in schema.patternProperties) {
			var regexp = new RegExp(patternKey);
			if (regexp.test(key)) {
			    foundMatch = true;
			    if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
				return error;
			    }
			}
		    }
		}
		if (!foundMatch) {
		    if (schema.additionalProperties !== undefined) {
			if (this.trackUnknownProperties) {
			    this.knownPropertyPaths[keyPointerPath] = true;
			    delete this.unknownPropertyPaths[keyPointerPath];
			}
			if (typeof schema.additionalProperties === "boolean") {
			    if (!schema.additionalProperties) {
				error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, "additionalProperties");
				if (this.handleError(error)) {
				    return error;
				}
			    }
			} else {
			    if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
				return error;
			    }
			}
		    } else if (this.trackUnknownProperties &amp;&amp; !this.knownPropertyPaths[keyPointerPath]) {
			this.unknownPropertyPaths[keyPointerPath] = true;
		    }
		} else if (this.trackUnknownProperties) {
		    this.knownPropertyPaths[keyPointerPath] = true;
		    delete this.unknownPropertyPaths[keyPointerPath];
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	    var error;
	    if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
		    if (data[depKey] !== undefined) {
			var dep = schema.dependencies[depKey];
			if (typeof dep === "string") {
			    if (data[dep] === undefined) {
				error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}).prefixWith(null, depKey).prefixWith(null, "dependencies");
				if (this.handleError(error)) {
				    return error;
				}
			    }
			} else if (Array.isArray(dep)) {
			    for (var i = 0; i &lt; dep.length; i++) {
				var requiredKey = dep[i];
				if (data[requiredKey] === undefined) {
				    error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}).prefixWith(null, "" + i).prefixWith(null, depKey).prefixWith(null, "dependencies");
				    if (this.handleError(error)) {
					return error;
				    }
				}
			    }
			} else {
			    if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
				return error;
			    }
			}
		    }
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	    return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;
	};

	ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	    if (schema.allOf === undefined) {
		return null;
	    }
	    var error;
	    for (var i = 0; i &lt; schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
		    return error;
		}
	    }
	    return null;
	};

	ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	    if (schema.anyOf === undefined) {
		return null;
	    }
	    var errors = [];
	    var startErrorCount = this.errors.length;
	    var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	    if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	    }
	    var errorAtEnd = true;
	    for (var i = 0; i &lt; schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
		    this.unknownPropertyPaths = {};
		    this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null &amp;&amp; errorCount === this.errors.length) {
		    this.errors = this.errors.slice(0, startErrorCount);

		    if (this.trackUnknownProperties) {
			for (var knownKey in this.knownPropertyPaths) {
			    oldKnownPropertyPaths[knownKey] = true;
			    delete oldUnknownPropertyPaths[knownKey];
			}
			for (var unknownKey in this.unknownPropertyPaths) {
			    if (!oldKnownPropertyPaths[unknownKey]) {
				oldUnknownPropertyPaths[unknownKey] = true;
			    }
			}
			// We need to continue looping so we catch all the
			// property definitions, but we don't want to return an
			// error
			errorAtEnd = false;
			continue;
		    }

		    return null;
		}
		if (error) {
		    errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	    }
	    if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	    }
	    if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors);
	    }
	};

	ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	    if (schema.oneOf === undefined) {
		return null;
	    }
	    var validIndex = null;
	    var errors = [];
	    var startErrorCount = this.errors.length;
	    var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	    if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	    }
	    for (var i = 0; i &lt; schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
		    this.unknownPropertyPaths = {};
		    this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null &amp;&amp; errorCount === this.errors.length) {
		    if (validIndex === null) {
			validIndex = i;
		    } else {
			this.errors = this.errors.slice(0, startErrorCount);
			return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf");
		    }
		    if (this.trackUnknownProperties) {
			for (var knownKey in this.knownPropertyPaths) {
			    oldKnownPropertyPaths[knownKey] = true;
			    delete oldUnknownPropertyPaths[knownKey];
			}
			for (var unknownKey in this.unknownPropertyPaths) {
			    if (!oldKnownPropertyPaths[unknownKey]) {
				oldUnknownPropertyPaths[unknownKey] = true;
			    }
			}
		    }
		} else if (error) {
		    errors.push(error);
		}
	    }
	    if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	    }
	    if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors);
	    } else {
		this.errors = this.errors.slice(0, startErrorCount);
	    }
	    return null;
	};

	ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	    if (schema.not === undefined) {
		return null;
	    }
	    var oldErrorCount = this.errors.length;
	    var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	    if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	    }
	    var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	    var notErrors = this.errors.slice(oldErrorCount);
	    this.errors = this.errors.slice(0, oldErrorCount);
	    if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	    }
	    if (error === null &amp;&amp; notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not");
	    }
	    return null;
	};

	ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
	    if (!schema.links) {
		return null;
	    }
	    var error;
	    for (var i = 0; i &lt; schema.links.length; i++) {
		var ldo = schema.links[i];
		if (ldo.rel === "describedby") {
		    var template = new UriTemplate(ldo.href);
		    var allPresent = true;
		    for (var j = 0; j &lt; template.varNames.length; j++) {
			if (!(template.varNames[j] in data)) {
			    allPresent = false;
			    break;
			}
		    }
		    if (allPresent) {
			var schemaUrl = template.fillFromObject(data);
			var subSchema = {"$ref": schemaUrl};
			if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
			    return error;
			}
		    }
		}
	    }
	};

	// parseURI() and resolveUrl() are from https://gist.github.com/1088850
	// - released as public domain by author ("Yaffle") - see comments on
	// gist

	function parseURI(url) {
	    var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	    // authority = '//' + user + ':' + pass '@' + hostname + ':' port
	    return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	    } : null);
	}

	function resolveUrl(base, href) {// RFC 3986

	    function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
		.replace(/\/(\.(\/|$))+/g, '/')
		.replace(/\/\.\.$/, '/../')
		.replace(/\/?[^\/]*/g, function (p) {
		    if (p === '/..') {
			output.pop();
		    } else {
			output.push(p);
		    }
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	    }

	    href = parseURI(href || '');
	    base = parseURI(base || '');

	    return !href || !base ? null : (href.protocol || base.protocol) +
		    (href.protocol || href.authority ? href.authority : base.authority) +
		    removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority &amp;&amp; !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		    (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		    href.hash;
	}

	function getDocumentUri(uri) {
	    return uri.split('#')[0];
	}
	function normSchema(schema, baseUri) {
	    if (schema &amp;&amp; typeof schema === "object") {
		if (baseUri === undefined) {
		    baseUri = schema.id;
		} else if (typeof schema.id === "string") {
		    baseUri = resolveUrl(baseUri, schema.id);
		    schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
		    for (var i = 0; i &lt; schema.length; i++) {
			normSchema(schema[i], baseUri);
		    }
		} else {
		    if (typeof schema['$ref'] === "string") {
			schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
		    }
		    for (var key in schema) {
			if (key !== "enum") {
			    normSchema(schema[key], baseUri);
			}
		    }
		}
	    }
	}

	var ErrorCodes = {
		INVALID_TYPE: 0,
		ENUM_MISMATCH: 1,
		ANY_OF_MISSING: 10,
		ONE_OF_MISSING: 11,
		ONE_OF_MULTIPLE: 12,
		NOT_PASSED: 13,
		// Numeric errors
		NUMBER_MULTIPLE_OF: 100,
		NUMBER_MINIMUM: 101,
		NUMBER_MINIMUM_EXCLUSIVE: 102,
		NUMBER_MAXIMUM: 103,
		NUMBER_MAXIMUM_EXCLUSIVE: 104,
		NUMBER_NOT_A_NUMBER: 105,
		// String errors
		STRING_LENGTH_SHORT: 200,
		STRING_LENGTH_LONG: 201,
		STRING_PATTERN: 202,
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: 300,
		OBJECT_PROPERTIES_MAXIMUM: 301,
		OBJECT_REQUIRED: 302,
		OBJECT_ADDITIONAL_PROPERTIES: 303,
		OBJECT_DEPENDENCY_KEY: 304,
		// Array errors
		ARRAY_LENGTH_SHORT: 400,
		ARRAY_LENGTH_LONG: 401,
		ARRAY_UNIQUE: 402,
		ARRAY_ADDITIONAL_ITEMS: 403,
		// Custom/user-defined errors
		FORMAT_CUSTOM: 500,
		KEYWORD_CUSTOM: 501,
		// Schema structure
		CIRCULAR_REFERENCE: 600,
		// Non-standard validation options
		UNKNOWN_PROPERTY: 1000
	};
	var ErrorCodeLookup = {};
	for (var key in ErrorCodes) {
	    ErrorCodeLookup[ErrorCodes[key]] = key;
	}
	// TODO: bundle this
	var ErrorMessagesDefault = {
		INVALID_TYPE: "Invalid type: {type} (expected {expected})",
		ENUM_MISMATCH: "No enum match for: {value}",
		ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
		ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
		ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
		NOT_PASSED: "Data matches schema from \"not\"",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
		NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
		NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
		NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
		// String errors
		STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
		STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
		STRING_PATTERN: "String does not match pattern: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
		OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
		OBJECT_REQUIRED: "Missing required property: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
		OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
		ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
		ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
		ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
		// Format errors
		FORMAT_CUSTOM: "Format validation failed ({message})",
		KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
		// Schema structure
		CIRCULAR_REFERENCE: "Circular $refs: {urls}",
		// Non-standard validation options
		UNKNOWN_PROPERTY: "Unknown property (not in schema)"
	};

	function ValidationError(code, message, params, dataPath, schemaPath, subErrors) {
	    Error.call(this);
	    if (code === undefined) {
		throw new Error ("No code supplied for error: "+ message);
	    }
	    this.message = message;
	    this.params = params;
	    this.code = code;
	    this.dataPath = dataPath || "";
	    this.schemaPath = schemaPath || "";
	    this.subErrors = subErrors || null;

	    var err = new Error(this.message);
	    this.stack = err.stack || err.stacktrace;
	    if (!this.stack) {
		try {
		    throw err;
		}
		catch(err) {
		    this.stack = err.stack || err.stacktrace;
		}
	    }
	}
	ValidationError.prototype = Object.create(Error.prototype);
	ValidationError.prototype.constructor = ValidationError;
	ValidationError.prototype.name = 'ValidationError';

	ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	    if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	    }
	    if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	    }
	    if (this.subErrors !== null) {
		for (var i = 0; i &lt; this.subErrors.length; i++) {
		    this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	    }
	    return this;
	};

	function isTrustedUrl(baseUrl, testUrl) {
	    if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 &amp;&amp; testUrl.charAt(baseUrl.length - 1) === "/") || remainder.charAt(0) === "#" || remainder.charAt(0) === "?") {
		    return true;
		}
	    }
	    return false;
	}

	var languages = {};
	function createApi(language) {
	    var globalContext = new ValidatorContext();
	    var currentLanguage = language || 'en';
	    var api = {
		    addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		    },
		    language: function (code) {
			if (!code) {
			    return currentLanguage;
			}
			if (!languages[code]) {
			    code = code.split('-')[0]; // fall back to base
							// language
			}
			if (languages[code]) {
			    currentLanguage = code;
			    return code; // so you can tell if fall-back has
					    // happened
			}
			return false;
		    },
		    addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
			    if (messageMap[key] &amp;&amp; !messageMap[ErrorCodes[key]]) {
				messageMap[ErrorCodes[key]] = messageMap[key];
			    }
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if
						    // not yet defined
			    languages[code] = messageMap;
			    languages[rootCode] = messageMap;
			} else {
			    languages[code] = Object.create(languages[rootCode]);
			    for (key in messageMap) {
				if (typeof languages[rootCode][key] === 'undefined') {
				    languages[rootCode][key] = messageMap[key];
				}
				languages[code][key] = messageMap[key];
			    }
			}
			return this;
		    },
		    freshApi: function (language) {
			var result = createApi();
			if (language) {
			    result.language(language);
			}
			return result;
		    },
		    validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var context = new ValidatorContext(globalContext, false, languages[currentLanguage], checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
			    schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error &amp;&amp; banUnknownProperties) {
			    error = context.banUnknownProperties();
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		    },
		    validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		    },
		    validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var context = new ValidatorContext(globalContext, true, languages[currentLanguage], checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
			    schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
			    context.banUnknownProperties();
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		    },
		    addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		    },
		    getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		    },
		    getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		    },
		    getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		    },
		    getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		    },
		    dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		    },
		    defineKeyword: function () {
			globalContext.defineKeyword.apply(globalContext, arguments);
		    },
		    defineError: function (codeName, codeNumber, defaultMessage) {
			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
			    // TODO message bundle this
			    throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
			}
			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber &lt; 10000) {
			    // TODO message bundle this
			    throw new Error('Code number must be an integer > 10000');
			}
			if (typeof ErrorCodes[codeName] !== 'undefined') {
			    // TODO message bundle this
			    throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
			}
			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
			    // TODO message bundle this
			    throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
			}
			ErrorCodes[codeName] = codeNumber;
			ErrorCodeLookup[codeNumber] = codeName;
			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
			for (var langCode in languages) {
			    var language = languages[langCode];
			    if (language[codeName]) {
				language[codeNumber] = language[codeNumber] || language[codeName];
			    }
			}
		    },
		    reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		    },
		    missing: [],
		    error: null,
		    valid: true,
		    normSchema: normSchema,
		    resolveUrl: resolveUrl,
		    getDocumentUri: getDocumentUri,
		    errorCodes: ErrorCodes
	    };
	    return api;
	}

	var tv4 = createApi();
	tv4.addLanguage('en-us', ErrorMessagesDefault);  // changed to US
							    // Engilsh

	// legacy property
	tv4.tv4 = tv4;

	return tv4;
    };
    // End of TV4 fork, will provide base JSON-Schema Draft 4 support and then some


    /**
     * Fork of Jquery i18n plugin turned component
     * Load and parse message bundle files (.properties), making bundles
	 * keys available as javascript variables.
	 *
	 * i18n files are named &lt;name>.js, or &lt;name>_&lt;language>.js or &lt;name>_&lt;language>_&lt;country>.js
	 * Where: The &lt;language> argument is a valid ISO Language Code. These
	 * codes are the lower-case, two-letter codes as defined by ISO-639. You
	 * can find a full list of these codes at a number of sites, such as:
	 * http://www.loc.gov/standards/iso639-2/englangn.html The &lt;country>
	 * argument is a valid ISO Country Code. These codes are the upper-case,
	 * two-letter codes as defined by ISO-3166. You can find a full list of
	 * these codes at a number of sites, such as:
	 * http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html
	 *
	 * Sample usage for a bundles/Messages.properties bundle:
	 * i18n.properties({ name: 'Messages', language: 'en_US', path:
	 * 'bundles' });
     *
     * @constructor i18nBase
     */
    var i18nBase = function() {
	var i18n = {};

	/** Map holding bundle keys (if mode: 'map') */
	i18n.map = {};

	/**
	 *
     * @function properties
     * @memberof i18nBase
	 *
	 * @param name
	 *                (string/string[], optional) names of file to load (eg,
	 *                'Messages' or ['Msg1','Msg2']). Defaults to "Messages"
	 * @param language
	 *                (string, optional) language/country code (eg, 'en',
	 *                'en_US', 'pt_PT'). if not specified, language reported
	 *                by the browser will be used instead.
	 * @param path
	 *                (string, optional) path of directory that contains
	 *                file to load
	 * @param mode
	 *                (string, optional) whether bundles keys are available
	 *                as JavaScript variables/functions or as a map (eg,
	 *                'vars' or 'map')
	 * @param cache
	 *                (boolean, optional) whether bundles should be cached
	 *                by the browser, or forcibly reloaded on each page
	 *                load. Defaults to false (i.e. forcibly reloaded)
	 * @param encoding
	 *                (string, optional) the encoding to request for
	 *                bundles. Property file resource bundles are specified
	 *                to be in ISO-8859-1 format. Defaults to UTF-8 for
	 *                backward compatibility.
	 * @param callback
	 *                (function, optional) callback function to be called
	 *                after script is terminated
	 */
	this.properties = function(settings) {
	    // set up settings
	    var defaults = {
		    name: Augmented.Configuration.MessageBundle,//'Messages',
		    language: '',
		    path: '',
		    mode: 'vars',
		    cache: false,
		    encoding: 'UTF-8',
		    callback: null
	    };
	    settings = Augmented.Utility.extend(defaults, settings);
	    if (settings.language === null || settings.language === '') {
		settings.language = browserLang();
	    }
	    if (settings.language === null) {
		settings.language = '';
	    }

	    // load and parse bundle files
	    var files = getFiles(settings.name);
	    for (var i = 0; i &lt; files.length; i++) {
		// 1. load base (eg, Messages.properties)
		loadAndParseFile(settings.path + files[i] + '.properties', settings);
		// 2. with language code (eg, Messages_pt.properties)
		if (settings.language.length >= 2) {
		    loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 2) + '.properties', settings);
		}
		// 3. with language code and country code (eg,
		// Messages_pt_PT.properties)
		if (settings.language.length >= 5) {
		    loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 5) + '.properties', settings);
		}
	    }

	    // call callback
	    if (settings.callback) {
		settings.callback();
	    }
	};

	/**
	 * When configured with mode: 'map', allows access to bundle values by
	 * specifying its key. Eg, prop('com.company.bundles.menu_add')
   * @function prop
   * @memberof i18nBase
	 */
	this.prop = function(key /*
				     * Add parameters as function arguments as
				     * necessary
				     */) {
	    var value = i18n.map[key];
	    if (!value) {
		    return '[' + key + ']';
        }

	    var phvList;
	    if (arguments.length == 2 &amp;&amp; Array.isArray(arguments[1]))
		// An array was passed as the only parameter, so assume it is
		// the list of place holder values.
		phvList = arguments[1];

	    // Place holder replacement
	    /**
	     * Tested with: test.t1=asdf ''{0}'' test.t2=asdf '{0}'
	     * '{1}'{1}'zxcv test.t3=This is \"a quote" 'a''{0}''s'd{fgh{ij'
	     * test.t4="'''{'0}''" {0}{a} test.t5="'''{0}'''" {1} test.t6=a {1}
	     * b {0} c test.t7=a 'quoted \\ s\ttringy' \t\t x
	     *
	     * Produces: test.t1, p1 ==> asdf 'p1' test.t2, p1 ==> asdf {0}
	     * {1}{1}zxcv test.t3, p1 ==> This is "a quote" a'{0}'sd{fgh{ij
	     * test.t4, p1 ==> "'{0}'" p1{a} test.t5, p1 ==> "'{0}'" {1}
	     * test.t6, p1 ==> a {1} b p1 c test.t6, p1, p2 ==> a p2 b p1 c
	     * test.t6, p1, p2, p3 ==> a p2 b p1 c test.t7 ==> a quoted \ s
	     * tringy x
	     */

	    var i;
	    if (typeof(value) == 'string') {
		// Handle escape characters. Done separately from the tokenizing
		// loop below because escape characters are
		// active in quoted strings.
		i = 0;
		while ((i = value.indexOf('\\', i)) != -1) {
		    if (value.charAt(i + 1) == 't')
			value = value.substring(0, i) + '\t' + value.substring((i++) + 2); // tab
		    else if (value.charAt(i + 1) == 'r')
			value = value.substring(0, i) + '\r' + value.substring((i++) + 2); // return
		    else if (value.charAt(i + 1) == 'n')
			value = value.substring(0, i) + '\n' + value.substring((i++) + 2); // line
											    // feed
		    else if (value.charAt(i + 1) == 'f')
			value = value.substring(0, i) + '\f' + value.substring((i++) + 2); // form
											    // feed
		    else if (value.charAt(i + 1) == '\\')
			value = value.substring(0, i) + '\\' + value.substring((i++) + 2); // \
		    else
			value = value.substring(0, i) + value.substring(i + 1); // Quietly
										// drop
										// the
										// character
		}

		// Lazily convert the string to a list of tokens.
		var arr = [], j, index;
		i = 0;
		while (i &lt; value.length) {
		    if (value.charAt(i) == '\'') {
			// Handle quotes
			if (i == value.length - 1)
			    value = value.substring(0, i); // Silently drop the
							    // trailing quote
			else if (value.charAt(i + 1) == '\'')
			    value = value.substring(0, i) + value.substring(++i); // Escaped
										    // quote
			else {
			    // Quoted string
			    j = i + 2;
			    while ((j = value.indexOf('\'', j)) != -1) {
				if (j == value.length - 1 || value.charAt(j + 1) != '\'') {
				    // Found start and end quotes. Remove them
				    value = value.substring(0, i) + value.substring(i + 1, j) + value.substring(j + 1);
				    i = j - 1;
				    break;
				}
				else {
				    // Found a double quote, reduce to a single
				    // quote.
				    value = value.substring(0, j) + value.substring(++j);
				}
			    }

			    if (j == -1) {
				// There is no end quote. Drop the start quote
				value = value.substring(0, i) + value.substring(i + 1);
			    }
			}
		    }
		    else if (value.charAt(i) == '{') {
			// Beginning of an unquoted place holder.
			j = value.indexOf('}', i + 1);
			if (j == -1)
			    i++; // No end. Process the rest of the line.
				    // Java would throw an exception
			else {
			    // Add 1 to the index so that it aligns with the
			    // function arguments.
			    index = parseInt(value.substring(i + 1, j));
			    if (!isNaN(index) &amp;&amp; index >= 0) {
				// Put the line thus far (if it isn't empty)
				// into the array
				var s = value.substring(0, i);
				if (s !== "")
				    arr.push(s);
				// Put the parameter reference into the array
				arr.push(index);
				// Start the processing over again starting from
				// the rest of the line.
				i = 0;
				value = value.substring(j + 1);
			    }
			    else
				i = j + 1; // Invalid parameter. Leave as is.
			}
		    }
		    else
			i++;
		}

		// Put the remainder of the no-empty line into the array.
		if (value !== "")
		    arr.push(value);
		value = arr;

		// Make the array the value for the entry.
		i18n.map[key] = arr;
	    }

	    if (value.length === 0)
		return "";
	    if (value.lengh == 1 &amp;&amp; typeof(value[0]) == "string")
		return value[0];

	    var s = "";
	    for (i = 0; i &lt; value.length; i++) {
		if (typeof(value[i]) == "string")
		    s += value[i];
		// Must be a number
		else if (phvList &amp;&amp; value[i] &lt; phvList.length)
		    s += phvList[value[i]];
		else if (!phvList &amp;&amp; value[i] + 1 &lt; arguments.length)
		    s += arguments[value[i] + 1];
		else
		    s += "{" + value[i] + "}";
	    }

	    return s;
	};

	/*
   * Language reported by browser, normalized code
   */
	function browserLang() {
	    return normaliseLanguageCode(navigator.language /* Mozilla */ || navigator.userLanguage /* IE */);
	}

	/** Load and parse .properties files
   * @function loadAndParseFile
   * @memberof i18nBase
   * @param filename
   * @param settings
   */
	function loadAndParseFile(filename, settings) {
	    ajax({
		url: filename,
		async: false,
		cache: settings.cache,
		contentType: 'text/plain;charset=' + settings.encoding,
		dataType: 'text',
		success: function (data, status) {
		    parseData(data, settings.mode);
		}
	    });
	}

	/*
   * Parse .properties files
   */
	function parseData(data, mode) {
	    var parsed = '';
	    var parameters = data.split(/\n/);
	    var regPlaceHolder = /(\{\d+\})/g;
	    var regRepPlaceHolder = /\{(\d+)\}/g;
	    var unicodeRE = /(\\u.{4})/ig;
	    for (var i = 0; i &lt; parameters.length; i++) {
		parameters[i] = parameters[i].replace(/^\s\s*/, '').replace(/\s\s*$/, ''); // trim
		if (parameters[i].length > 0 &amp;&amp; parameters[i].match("^#") != "#") { // skip
										    // comments
		    var pair = parameters[i].split('=');
		    if (pair.length > 0) {
			/** Process key &amp; value */
			var name = unescape(pair[0]).replace(/^\s\s*/, '').replace(/\s\s*$/, ''); // trim
			var value = pair.length == 1 ? "" : pair[1];
			// process multi-line values
			while (value.match(/\\$/) == "\\") {
			    value = value.substring(0, value.length - 1);
			    value += parameters[++i].replace(/\s\s*$/, ''); // right
									    // trim
			}
			// Put values with embedded '='s back together
			for (var s = 2; s &lt; pair.length; s++) {
			    value += '=' + pair[s];
			}
			value = value.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); // trim

			/** Mode: bundle keys in a map */
			if (mode == 'map' || mode == 'both') {
			    // handle unicode chars possibly left out
			    var unicodeMatches = value.match(unicodeRE);
			    if (unicodeMatches) {
				for (var u = 0; u &lt; unicodeMatches.length; u++) {
				    value = value.replace(unicodeMatches[u], unescapeUnicode(unicodeMatches[u]));
				}
			    }
			    // add to map
			    i18n.map[name] = value;
			}

			/* Mode: bundle keys as vars/functions */
			if (mode == 'vars' || mode == 'both') {
			    value = value.replace(/"/g, '\\"'); // escape quotation mark

			    // make sure namespaced key exists (eg, some.key')
			    checkKeyNamespace(name);

			    // value with variable substitutions
			    if (regPlaceHolder.test(value)) {
				var parts = value.split(regPlaceHolder);
				// process function args
				var first = true;
				var fnArgs = '';
				var usedArgs = [];
				for (var p = 0; p &lt; parts.length; p++) {
				    if (regPlaceHolder.test(parts[p]) &amp;&amp; (usedArgs.length === 0 || usedArgs.indexOf(parts[p]) === -1)) {
					if (!first) {
					    fnArgs += ',';
					}
					fnArgs += parts[p].replace(regRepPlaceHolder, 'v$1');
					usedArgs.push(parts[p]);
					first = false;
				    }
				}
				parsed += name + '=function(' + fnArgs + '){';
				// process function body
				var fnExpr = '"' + value.replace(regRepPlaceHolder, '"+v$1+"') + '"';
				parsed += 'return ' + fnExpr + ';' + '};';

				// simple value
			    } else {
				parsed += name + '="' + value + '";';
			    }
			} // END: Mode: bundle keys as vars/functions
		    } // END: if(pair.length > 0)
		} // END: skip comments
	    }
	    eval(parsed);
	}

	/** Make sure namespace exists (for keys with dots in name) */
	// TODO key parts that start with numbers quietly fail. i.e.
	// month.short.1=Jan
	function checkKeyNamespace(key) {
	    var regDot = /\./;
	    if (regDot.test(key)) {
		var fullname = '';
		var names = key.split(/\./);
		for (var i = 0; i &lt; names.length; i++) {
		    if (i > 0) {
			fullname += '.';
		    }
		    fullname += names[i];
		    if (eval('typeof ' + fullname + ' == "undefined"')) {
			eval(fullname + '={};');
		    }
		}
	    }
	}

	/* Make sure filename is an array */
	function getFiles(names) {
	    return (names &amp;&amp; names.constructor == Array) ? names : [names];
	}

	/* Ensure language code is in the format aa_AA. */
	function normaliseLanguageCode(lang) {
	    lang = lang.toLowerCase();
	    if (lang.length > 3) {
		lang = lang.substring(0, 3) + lang.substring(3).toUpperCase();
	    }
	    return lang;
	}

	/* Unescape unicode chars ('\u00e3') */
	function unescapeUnicode(str) {
	    // unescape unicode codes
	    var codes = [];
	    var code = parseInt(str.substr(2), 16);
	    if (code >= 0 &amp;&amp; code &lt; Math.pow(2, 16)) {
		codes.push(code);
	    }
	    // convert codes to text
	    var unescaped = '';
	    for (var i = 0; i &lt; codes.length; ++i) {
		unescaped += String.fromCharCode(codes[i]);
	    }
	    return unescaped;
	}
};

    /* Assign an object if null */
    var resourceBundle = (!resourceBundle) ? new i18nBase() : resourceBundle;

/**
 * Augmented.Utility.ResourceBundle
 * @function Augmented.Utility.ResourceBundle
 */
    Augmented.Utility.ResourceBundle = {
        /**
         * getBundle
         * @function getBundle
         * @memberof Augmented.Utility.ResourceBundle
         */
	    getBundle: function() {
		    return resourceBundle.properties.apply(this, arguments);
	    },

        /**
         * getString
         * @function getString
         * @memberof Augmented.Utility.ResourceBundle
         */
	    getString: function() {
		    return resourceBundle.prop.apply(this, arguments);
	    }
    };

    /**
     * Augmented.Utility.MessageReader
     * @function Augmented.Utility.MessageReader
     */
    Augmented.Utility.MessageReader = {
        /**
         * getMessage
         * @function getMessage
         * @memberof Augmented.Utility.MessageReader
         * get the message out of the bundle.
         * if message is not found, then ResourceBundle returns the key
 		 * wrapped in square brackets
 		 * loop through the fallback path of the key by removing the
 		 * last attribute and searching the bundle again
 		 * stop when you get back a real message (not just the [key])
         */
	    getMessage: function(key) {
		// try getting the message out of the bundle
		var msg = Augmented.Utility.ResourceBundle.getString.apply(this,arguments),
		delimiter = ".",
		last = key.length,
		originalKey = key;
		// if message is not found, then ResourceBundle returns the key
		// wrapped in square brackets
		// loop through the fallback path of the key by removing the
		// last attribute and searching the bundle again
		// stop when you get back a real message (not just the [key])
		while ( last > 0 &amp;&amp; msg == '[' + key + ']') {
		    last = key.lastIndexOf(delimiter);
		    key = key.substring(0,last);
		    msg = Augmented.Utility.ResourceBundle.getString.apply(this,arguments);
		}
		// if the original key or a fallback was found, return the
		// message
		// otherwise return the original key with square brackets
		// (default jquery.i18n.properties plugin result)
		return key ? msg : "[" + originalKey + "]";
	    }
    };

    /**
     * Augmented.Utility.MessageKeyFormatter
     *
     * Concatenate the pieces of the error together if a portion of the key is
     * missing, the rest of the key is ignored. ex. if the "rule" attribute is
     * missing, then the key will return with the error.level + error.kind only
     * @function Augmented.Utility.MessageKeyFormatter
     */
    Augmented.Utility.MessageKeyFormatter = {
        /**
         * delimiter
         * @property delimiter
         * @memberof Augmented.Utility.MessageKeyFormatter
         */
	    delimiter: ".",
        /**
         * format
         * @function format
         * @memberof Augmented.Utility.MessageKeyFormatter
         */
	    format: function(error) {
    		var key = "";
            if (error) {
                var x = error.level &amp;&amp;
                (key += error.level, error.kind &amp;&amp;
                (key += this.delimiter + error.kind, error.rule &amp;&amp;
                (key += this.delimiter + error.rule, error.values.title &amp;&amp;
                (key += this.delimiter + error.values.title))));
            }
    		return (key) ? key : "";
	    }
    };

    /**
     * Augmented.ValidationFramework
     * The Validation Framework Base Wrapper Class
     * Provides abstraction for base validation build-in library
     * @constructor Augmented.ValidationFramework
     */
    var validationFramework = function() {
    	var myValidator;
    	if (myValidator === undefined) {
    	    myValidator = new Validator();
    	}

    	this.supportsValidation = function() {
    	    return (myValidator !== null);
    	};
    	this.registerSchema = function(identity, schema) {
    	    myValidator.addSchema(identity, schema);
    	};
    	this.getSchema = function(identity) {
    	    return myValidator.getSchema(identity);
    	};
    	this.getSchemas = function() {
    	    return myValidator.getSchemaMap();
    	};
    	this.clearSchemas = function() {
    	    myValidator.dropSchemas();
    	};
    	this.validate = function(data, schema) {
    	    return myValidator.validateMultiple(data, schema);
    	};
    	this.getValidationMessages = function() {
    	    return myValidator.error;
    	};
    };

    Augmented.ValidationFramework = (!Augmented.ValidationFramework) ? new validationFramework() : Augmented.ValidationFramework;

    /**
     * Abstract Augmented Model Supports: CORS Schemas Security
     * TODO: implement OAUTH 2
     * @constructor Augmented.Model
     */
    var augmentedModel = Backbone.Model.extend({
    	schema: null,
        mock: false,
    	validationMessages: {
    	    valid: true
    	},
    	supportsValidation: function() {
    	    if (this.schema !== null) {
    		    return true;
    	    }
    	    return false;
    	},
    	isValid: function() {
    	    this.validate();
    	    return this.validationMessages.valid;
    	},
    	validate: function() {
    	    if (this.supportsValidation() &amp;&amp; Augmented.ValidationFramework.supportsValidation()) {
    		    // validate from Validator
    		    this.validationMessages = Augmented.ValidationFramework.validate(this.toJSON(), this.schema);
    	    } else {
    		    this.validationMessages.valid = true;
    	    }
    	    return this.validationMessages;
    	},
    	crossOrigin: false,
    	sync: function(method, model, options) {
    	    if (!options) {
    		    options = {};
    	    }
    	    if (this.crossOrigin === true) {
    		    options.crossDomain = true;
    	    }
    	    if (!options.xhrFields) {
        		options.xhrFields = {
        			withCredentials: true
        		};
    	    }

            if (this.mock) {
                options.mock = this.mock;
            }

            ret = Augmented.sync(method, model, options);

    	    return ret;
    	}
    });

    // Extend Model with Object base functions
    Augmented.Utility.extend(augmentedModel, Augmented.Object);

    /**
     * Abstract Augmented Collection Supports: CORS Schemas Security * TODO:
     * implement OAUTH 2
     */
    var augmentedCollection = Backbone.Collection.extend({
    	schema: null,
        mock: false,
    	validationMessages: {
    	    valid: true
    	},
    	supportsValidation: function() {
    	    if (this.schema !== null) {
    		    return true;
    	    }
    	    return false;
    	},
    	isValid: function() {
    	    this.validate();
    	    return this.validationMessages.valid;
    	},
    	validate: function() {
    	    if (this.supportsValidation() &amp;&amp; Augmented.ValidationFramework.supportsValidation()) {
    		// validate from Validator

    		// TODO: Should we validate every model to call this valid or is
    		// this be a 'instance' validation?
    		this.validationMessages = Augmented.ValidationFramework.validate(this.toJSON(), this.schema);
    	    } else {
    		this.validationMessages.valid = true;
    	    }
    	    return this.validationMessages;
    	},
    	crossOrigin: false,
    	sync: function(method, model, options) {
    	    if (!options) {
    		    options = {};
    	    }
    	    if (this.crossOrigin === true) {
    		    options.crossDomain = true;
    	    }
    	    if (!options.xhrFields) {
    		    options.xhrFields = {
        			withCredentials: true
        		};
    	    }

            if (this.mock) {
                options.mock = this.mock;
            }

            ret = Backbone.sync(method, model, options);
    	    return ret;
    	}
    });

	// Extend Collection with Object base functions
    Augmented.Utility.extend(augmentedCollection, Augmented.Object);

    var paginatedCollection = Augmented.PaginatedCollection = augmentedCollection.extend({
        paginationConfiguration: {
            currentPageParam: "page",
            pageSizeParam: "per_page"
        },
        pageSize: 20,
        currentPage: 1,
        totalPages: 1,
        setPageSize: function(size) {
            if (size) {
                this.pageSize = size;
            }
            this.refresh();
        },
        setCurrentPage: function(page) {
            if (!page) {
                page = 1;
            }
            this.currentPage = page;
            this.refresh();
        },
        setPaginationConfiguration: function(config) {
            this.paginationConfiguration = config;
        },
        fetch: function(options) {
            options = (options) ? options : {};
            var data = (options.data || {});
            var p = this.paginationConfiguration;
            var d = {};
            d[p.currentPageParam] = this.currentPage;
            d[p.pageSizeParam] = this.pageSize;

            options.data = d;

            var xhr = Augmented.Collection.prototype.fetch.call(this, options);

            // TODO: parse header links to sync up vars

            return xhr;
        },
        nextPage: function() {
            if (this.currentPage &lt; this.totalPages) {
                this.currentPage = this.currentPage + 1;
                this.refresh();
            }
        },
        previousPage: function() {
            if (this.currentPage > 0) {
                this.currentPage = this.currentPage - 1;
                this.refresh();
            }
        },
        goToPage: function(page) {
            if ((page) &amp;&amp; (page &lt; this.totalPages) &amp;&amp; (page > 0)) {
                this.currentPage = page;
                this.refresh();
            }
        },
        firstPage: function() {
            this.currentPage = 1;
            this.refresh();
        },
        lastPage: function() {
            this.currentPage = this.totalPages;
            this.refresh();
        },
        refresh: function() {
            this.fetch();
        }
    });

    var paginationAPIType = {
        github: "github",
        solr: "solr",
        database: "database"
    };

    var paginationFactory = Augmented.PaginationFactory = {
        type: paginationAPIType,
        getPaginatedCollection: function(apiType, data) {
            var arg = (data) ? data : {};
            var collection= null;

            if (!apiType) {
                apiType = paginationAPIType.github;
            }
            if (apiType === paginationAPIType.github) {
                collection = new paginatedCollection(arg);
                collection.setPaginationConfiguration({
                    currentPageParam: "page",
                    pageSizeParam: "per_page"
                });
            } else if (apiType === paginationAPIType.solr) {
                collection = new paginatedCollection(arg);
                collection.setPaginationConfiguration({
                    currentPageParam: "start",
                    pageSizeParam: "rows"
                });
            } else if (apiType === paginationAPIType.database) {
                collection = new paginatedCollection(arg);
                collection.setPaginationConfiguration({
                    currentPageParam: "offset",
                    pageSizeParam: "limit"
                });
            }
            return collection;
        }
    };

    var augmentedView = Backbone.View.extend({
        initialize: function(options) {
            this.render = _.wrap(this.render, function(render) {
                this.beforeRender();
                render();
                this.afterRender();
                return this;
            });
        },
        beforeRender: function() {
        },
        render: function() {
            return this;
        },
        afterRender: function() {
        },
        name: "",
        setName: function(name) {
            this.name = name;
        },
        getName: function() {
            return this.name;
        },
        permissions: {
            include: [],
            exclude: []
        },
        addPermission: function(permission, negative) {
            if (permission !== null &amp;&amp; !Array.isArray(permission)) {
                var p = (negative) ? this.permissions.exclude : this.permissions.include;
                p.push(permission);
            }
        },
        removePermission: function(permission, negative) {
            if (permission !== null &amp;&amp; !Array.isArray(permission)) {
                var p = (negative) ? this.permissions.exclude : this.permissions.include;
                p.splice((p.indexOf(permission)), 1);
            }
        },
        setPermissions: function(permissions, negative) {
            if (permissions !== null &amp;&amp; Array.isArray(permissions)) {
                if (negative) {
                    this.permissions.exclude = permissions;
                } else {
                    this.permissions.include = permissions;
                }
            }
        },
        getPermissions: function() {
            return this.permissions;
        },
        clearPermissions: function() {
            this.permissions = {
                include: [],
                exclude: []
            };
        },
        matchesPermission: function(match, negative) {
            var p = (negative) ? this.permissions.exclude : this.permissions.include;
            return (p.indexOf(match) !== -1);
        },
        canDisplay: function() {
            return true;
        }
    });

    // Extend View with Object base functions
    Augmented.Utility.extend(augmentedView, Augmented.Object);

    /** Augmented Backbone - Extend Backbone with awesome */
    Augmented.Model = augmentedModel;
    Augmented.Collection = augmentedCollection;
    Augmented.View = augmentedView;
    Augmented.history = Backbone.history;
    Augmented.History = Backbone.History;
    Augmented.Router = Backbone.Router;
    Augmented.$ = Backbone.$; // Does jQuery exist?

    /** Core Package */

    /** local Storage */

    var augmentedLocalStorage = function(persist) {
    	this.isPersisted = persist;
    	this.myStore = null;
    	this.isSupported = function() {
    	    return (typeof (Storage) !== "undefined");
    	};

    	// true = localStorage, false = sessionStorage
    	if (this.isSupported()) {
    	    logger.debug("localStorage exists");

    	    if (this.isPersisted) {
    		this.myStore = localStorage;
    	    } else {
    		this.myStore = sessionStorage;
    	    }
    	} else {
    	    logger.debug("No localStorage.");
    	}

    	this.getItem = function(itemKey) {
    	    var item = this.myStore.getItem(itemKey);
    	    if (item) {
    		    return JSON.parse(item);
    	    }
    	    return null;
    	};

    	this.setItem = function(itemKey, object) {
    	    this.myStore.setItem(itemKey, JSON.stringify(object));
    	};

    	this.removeItem = function(itemKey) {
    	    this.myStore.removeItem(itemKey);
    	};

    	this.clear = function() {
    	    this.myStore.clear();
    	};

    	this.key = function(i) {
    	    return this.myStore.key(i);
    	};

    	this.length = function() {
    	    return this.myStore.length;
    	};
    };

    var namespacedAugmentedLocalStorage = function(persist,namespace) {
    	var ls = localStorageFactory.getStorage(persist);
    	this.myNameSpacedStore = new Augmented.Utility.AugmentedMap();
    	this.namespace = namespace;

    	// public
    	this.isSupported = function() {
    	    return (ls &amp;&amp; ls.isSupported());
    	};

    	// true = localStorage, false = sessionStorage
    	if (this.isSupported() &amp;&amp; this.namespace) {
    	    ls.setItem(this.namespace, JSON.stringify(this.myNameSpacedStore.toJSON()));
    	}

    	this.getItem = function(itemKey) {
            var map = {};
            try {
    	        map = JSON.parse(ls.getItem(this.namespace));
            } catch(e) {
                // TODO: bundle this
                logger.error("Could not parse item map from storage!");
                return null;
            }
            this.myNameSpacedStore.clear();
            this.myNameSpacedStore.marshall(map);

    	    var item = this.myNameSpacedStore.get(itemKey);

    	    if (item) {
    		    // support regular string as well as object
        		var ret;
        		try {
        		    ret = JSON.parse(item);
        		} catch(e){
        		    // not JSON
        		    ret = item;
        		}
        		return ret;
    	    }
    	    return null;
    	};

    	this.setItem = function(itemKey, object) {
            if (!this.myNameSpacedStore) {
    		    this.myNameSpacedStore = new Augmented.Utility.AugmentedMap();
    	    }
    	    this.myNameSpacedStore.set(itemKey, object);
    	    ls.setItem(namespace, JSON.stringify(this.myNameSpacedStore.toJSON()));
    	};

    	this.removeItem = function(itemKey) {
    	    var item = this.getItem(itemKey);

    	    this.myNameSpacedStore.remove(itemKey);
    	    ls.setItem(namespace, JSON.stringify(this.myNameSpacedStore.toJSON()));
    	};

    	this.clear = function() {
    	    this.myNameSpacedStore.clear();
    	    ls.setItem(namespace, JSON.stringify(this.myNameSpacedStore.toJSON()));
    	};

    	this.key = function(i) {
    	    return this.myNameSpacedStore.key(i);
    	};

    	this.length = function() {
    	    return this.myNameSpacedStore.size();
    	};
    };

    /**
     * Augmented.LocalStorageFactory
     * Retrieve a local storage Object
     * @function
     */
    var localStorageFactory = Augmented.LocalStorageFactory = {
	    getStorage: function(persist, namespace) {
    		var ls = null;
    		if (namespace) {
    		    ls = new namespacedAugmentedLocalStorage(persist,namespace);
    		} else {
    		    ls = new augmentedLocalStorage(persist);
    		}
    		if (ls &amp;&amp; ls.isSupported()) {
    		    return ls;
    		}
    		return null;
	    }
    };

    /**
     * Augmented.Utility.Stack
     * Standard Stack data structure
     * @class Augmented.Utility.Stack
     */
    var stack = Augmented.Utility.Stack = function() {
        this.stack = [];
        this.empty = function() {
            return (this.stack.length === 0);
        };
        this.peek = function() {
            return this.stack[0];
        };
        this.pop = function() {
            return this.stack.pop();
        };
        this.push = function(item) {
            this.stack.push(item);
        };
        this.search = function(item) {
            return this.stack.indexOf(item);
        };
        this.size = function() {
            return this.stack.length;
        };
        this.clear = function() {
            this.stack.splice(0, this.stack.length);
        };
        this.toArray = function() {
            return this.stack;
        };
    };

    /**
     * Augmented.Utility.AsynchronousQueue
     * An Async queue for handling async chained functions
     * @constructor Augmented.Utility.AsynchronousQueue
     */
    var asyncQueue = Augmented.Utility.AsynchronousQueue = function(timeout) {
        var to = (timeout) ? timeout : Augmented.Configuration.AsynchronousQueueTimeout;
        this.queue = {};

        this.add = function() {
            var args = arguments;
            if (args.length &lt;= 0) {
                return false;
            }

            Augmented.Utility.extend(this.queue, args);
        };

        this.clear = function() {
            if (this.queue.length > 0) {
                this.queue.splice(0, this.queue.length);
            }
        };

        this.process = function() {
            if (arguments) {
                Augmented.Utility.extend(this.queue, arguments);
            }
            var args = this.queue;
            if (args.length &lt;= 0) {
                return false;
            }
            (function chain(i) {
                if (i >= args.length || typeof args[i] !== 'function') {
                    return false;
                }
                window.setTimeout(function() {
                    args[i]();
                    chain(i + 1);
                }, to);
            })(0);
            return true;
        };
        this.getTimeout = function() {
            return to;
        };
        this.getQueue = function() {
            return this.queue;
        };
    };

    /**
     * &lt;p>Application Class for use to define an application.&lt;br/>
     * An application contains metadata and initializers for the application.&lt;br/>
     * &lt;em>Applications track history, and normally would contain the entire single page App startup.&lt;/em>&lt;/p>
     * @example var app = new Augmented.Application();
     * app.setName("My Super Application!");
     * app.setMetadataItem("description", "something very awesome");
     * app.beforeInitialize() = function() { do some stuff... };
     * app.start();
     * @constructor Augmented.Application
     */
    var application = Augmented.Application = function(name) {
		var metadata;
        this.started = false;

        if (!metadata) {
            metadata = new Augmented.Utility.AugmentedMap();
        } else {
            metadata.clear();
        }

        if (name) {
            metadata.set("name", name);
        } else {
            metadata.set("name", "untitled");
        }

        /** Event for after during startup of the application
         * @function initialize
         * @memberof Augmented.Application
         */
        this.initialize = function() {

        };
        /** Event for before the startup of the application
         * @function beforeInitialize
         * @memberof Augmented.Application
         */
        this.beforeInitialize = function() {

        };
        /** Event for after the startup of the application
         * @function afterInitialize
         * @memberof Augmented.Application
         */
        this.afterInitialize = function() {

        };

        /** Get the application name
         * @function getName
         * @memberof Augmented.Application
         */
        this.getName = function() {
            return this.getMetadataItem("name");
        };

        /** Set the application name
         * @function setName
         * @memberof Augmented.Application
         */
        this.setName = function(n) {
            return this.setMetadataItem("name", n);
        };

        /** Get the metadata map
         * @function getMetadata
         * @memberof Augmented.Application
         * @returns Map of metadata in an Augmented.Utility.AugmentedMap
         */
		this.getMetadata = function() {
			return metadata;
		};

        /** Set a specific item in metadata
         * @function setMetadataItem
         * @memberof Augmented.Application
         */
		this.setMetadataItem = function(key, value) {
			metadata.set(key, value);
		};

        /** Get a specific item in metadata
         * @function getMetadataItem
         * @memberof Augmented.Application
         */
		this.getMetadataItem = function(key) {
			return metadata.get(key);
		};

        /** Event to start the application and history
         * @function start
         * @memberof Augmented.Application
         */
		this.start = function() {
            var asyncQueue = new Augmented.Utility.AsynchronousQueue(Augmented.Configuration.ApplicationInitProcessTimeout);
            this.started = asyncQueue.process(
                this.beforeInitialize(),
                this.initialize(),
                this.afterInitialize(),
                function() {
                    if (!Augmented.history.started) {
        				Augmented.history.start();
        		    }
                }
            );
            if (!this.started) {
                this.stop();
            }
		};

        /** Event to stop the application and history
         * @function stop
         * @memberof Augmented.Application
         */
        this.stop = function() {
		    if (Augmented.history.started) {
				Augmented.history.stop();
		    }
		    this.started = false;
		};
    };
    Augmented.Application.prototype.constructor = application;

    return Augmented;
}));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Augmented.html">Augmented</a></li></ul><h3>Classes</h3><ul><li><a href="Augmented.Application.html">Application</a></li><li><a href="Augmented.Model.html">Model</a></li><li><a href="Augmented.Object.html">Object</a></li><li><a href="Augmented.Security.Context.html">Context</a></li><li><a href="Augmented.Utility.Array.html">Array</a></li><li><a href="Augmented.Utility.AsynchronousQueue.html">AsynchronousQueue</a></li><li><a href="Augmented.Utility.AugmentedMap.html">AugmentedMap</a></li><li><a href="Augmented.Utility.Stack.html">Stack</a></li><li><a href="Augmented.ValidationFramework.html">ValidationFramework</a></li><li><a href="module-Augmented-abstractLogger.html">abstractLogger</a></li><li><a href="module-Augmented-i18nBase.html">i18nBase</a></li></ul><h3>Namespaces</h3><ul><li><a href="Augmented.Logger.html">Logger</a></li><li><a href="Augmented.Security.html">Security</a></li><li><a href="Augmented.Utility.html">Utility</a></li><li><a href="Augmented.Utility.Transformer.html">Transformer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Nov 20 2015 13:44:33 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
